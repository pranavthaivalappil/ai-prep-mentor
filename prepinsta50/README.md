# PrepInsta Top 50 Coding Problems

A comprehensive collection of the most important coding problems for technical interviews and competitive programming practice. This repository contains well-documented Python solutions with multiple approaches, interactive examples, and detailed explanations.

## ğŸ“ Repository Structure

```
prepinsta50/
â”œâ”€â”€ numbers/          # Number theory and mathematical problems
â”œâ”€â”€ arrays/           # Array manipulation and algorithms
â”œâ”€â”€ strings/          # String processing and operations
â”œâ”€â”€ recursion/        # Recursive algorithms and solutions
â”œâ”€â”€ patterns/         # Pattern printing problems
â””â”€â”€ README.md         # This file
```

## ğŸ”¢ Numbers Category

### Problems Included:
1. **Positive/Negative Number Check** (`01_positive_negative.py`)
   - Check if a number is positive, negative, or zero
   - Interactive testing with multiple approaches

2. **Even/Odd Number Check** (`02_even_odd.py`)
   - Determine if a number is even or odd
   - Handles negative numbers and edge cases

3. **Sum of Natural Numbers** (`03_sum_natural_numbers.py`)
   - Calculate sum using formula, loop, and recursion
   - Performance comparison between methods

4. **Greatest of Numbers** (`04_greatest_of_numbers.py`)
   - Find greatest among 2, 3, or multiple numbers
   - Index tracking and statistical analysis

5. **Prime Number Operations** (`05_prime_numbers.py`)
   - Prime checking with multiple algorithms
   - Sieve of Eratosthenes implementation
   - Prime number generation and analysis

6. **Factorial Calculation** (`06_factorial.py`)
   - Iterative, recursive, and built-in approaches
   - Trailing zeros calculation
   - Large number handling

7. **Fibonacci Series** (`07_fibonacci.py`)
   - Multiple generation methods
   - Golden ratio formula implementation
   - Fibonacci number validation

8. **Armstrong Numbers** (`08_armstrong_number.py`)
   - Armstrong number checking and generation
   - Detailed breakdown of calculations
   - Range-based analysis

9. **Perfect Numbers** (`09_perfect_number.py`)
   - Perfect number identification
   - Mersenne prime relationship
   - Number classification (perfect/abundant/deficient)

10. **Palindrome Numbers** (`10_palindrome_number.py`)
    - Multiple palindrome checking methods
    - Lychrel number testing
    - Next/previous palindrome finding

## ğŸ“Š Arrays Category

### Problems Included:
1. **Largest and Smallest Elements** (`01_largest_smallest.py`)
   - Find min/max with multiple approaches
   - Kth largest/smallest elements
   - Index tracking and statistics

2. **Array Sum Calculation** (`02_array_sum.py`)
   - Various sum calculation methods
   - Positive/negative sum separation
   - Even/odd index and value sums

3. **Array Reversal** (`03_reverse_array.py`)
   - Multiple reversal techniques
   - Array rotation operations
   - Space preservation methods

4. **Array Sorting** (`04_sort_array.py`)
   - Implementation of major sorting algorithms
   - Performance comparison
   - Custom sorting criteria

5. **Remove Duplicates** (`05_remove_duplicates.py`)
   - Multiple duplicate removal strategies
   - Order preservation options
   - Frequency analysis and statistics

## ğŸ”¤ Strings Category

### Problems Included:
1. **Palindrome String Operations** (`01_palindrome_string.py`)
   - Multiple palindrome checking methods
   - Longest palindromic substring
   - Palindrome permutation checking

2. **String Reversal** (`02_reverse_string.py`)
   - Various reversal techniques
   - Word-level operations
   - Selective character reversal

3. **Vowels and Consonants** (`03_vowels_consonants.py`)
   - Count and analyze vowels/consonants
   - Position tracking and manipulation
   - Statistical analysis

4. **String Length Operations** (`04_string_length.py`)
   - Multiple length calculation methods
   - Character type analysis
   - Word-level statistics

5. **ASCII Value Operations** (`05_ascii_values.py`)
   - ASCII conversion and manipulation
   - Binary and hexadecimal representation
   - Character shifting and analysis

## ğŸ”„ Recursion Category

### Problems Included:
1. **Power Calculation** (`01_power_calculation.py`)
   - Recursive and optimized power calculation
   - Modular exponentiation
   - Power series and analysis

2. **HCF and LCM** (`02_hcf_lcm.py`)
   - Euclidean algorithm implementation
   - Extended Euclidean algorithm
   - Multiple number operations

3. **String Permutations** (`03_string_permutations.py`)
   - Generate all permutations recursively
   - Handle duplicate characters
   - Lexicographic operations

## ğŸ¨ Patterns Category

### Problems Included:
1. **Triangle Patterns** (`01_triangle_patterns.py`)
   - Right triangles with stars/numbers
   - Equilateral and hollow triangles
   - Pascal's triangle and Floyd's triangle

2. **Square Patterns** (`02_square_patterns.py`)
   - Solid and hollow squares
   - Number and alphabet patterns
   - Spiral and border patterns

3. **Diamond Patterns** (`03_diamond_patterns.py`)
   - Solid and hollow diamonds
   - Number and alphabet diamonds
   - Butterfly and hourglass patterns

## ğŸš€ Getting Started

### Prerequisites
- Python 3.6 or higher
- No external dependencies required

### Running the Programs

1. **Clone or download the repository**
```bash
git clone <repository-url>
cd prepinsta50
```

2. **Run individual programs**
```bash
python numbers/01_positive_negative.py
python arrays/01_largest_smallest.py
python strings/01_palindrome_string.py
# ... and so on
```

3. **Interactive Mode**
Each program includes an interactive mode where you can:
- Input your own test cases
- See step-by-step solutions
- Compare different approaches
- Analyze performance

### Example Usage

```python
# Example: Running the prime number checker
python numbers/05_prime_numbers.py

# The program will show:
# - Demonstration of prime checking methods
# - Prime number generation
# - Interactive input for testing your numbers
```

## ğŸ“š Features

### ğŸ¯ Multiple Approaches
Each problem includes several solution methods:
- **Brute Force**: Simple, easy-to-understand solutions
- **Optimized**: Efficient algorithms with better time complexity
- **Built-in**: Using Python's built-in functions
- **Mathematical**: Formula-based solutions where applicable

### ğŸ” Comprehensive Testing
- Pre-defined test cases covering edge cases
- Interactive input validation
- Performance benchmarking
- Error handling and user guidance

### ğŸ“– Educational Content
- Detailed comments explaining algorithms
- Time and space complexity analysis
- Best practices and coding patterns
- Real-world applications

### ğŸ® Interactive Learning
- User-friendly input prompts
- Step-by-step execution
- Multiple operation modes
- Immediate feedback and results

## ğŸ“ Learning Objectives

This collection helps you master:

### Programming Fundamentals
- **Control Structures**: Loops, conditionals, and branching
- **Data Structures**: Arrays, strings, and basic operations
- **Algorithms**: Searching, sorting, and optimization
- **Recursion**: Base cases, recursive thinking, and optimization

### Problem-Solving Skills
- **Pattern Recognition**: Identifying common problem types
- **Algorithm Design**: Creating efficient solutions
- **Code Optimization**: Improving time and space complexity
- **Testing**: Validating solutions with various inputs

### Interview Preparation
- **Common Questions**: Most frequently asked problems
- **Multiple Solutions**: Different approaches to same problem
- **Complexity Analysis**: Understanding Big O notation
- **Code Quality**: Clean, readable, and maintainable code

## ğŸ† Problem Difficulty Levels

### ğŸŸ¢ Beginner (Easy)
- Basic number operations
- Simple array manipulations
- String basics
- Pattern printing

### ğŸŸ¡ Intermediate (Medium)
- Algorithm implementations
- Recursive solutions
- Complex string operations
- Advanced patterns

### ğŸ”´ Advanced (Hard)
- Optimized algorithms
- Mathematical concepts
- Complex recursion
- Performance optimization

## ğŸ’¡ Tips for Success

### 1. **Start Simple**
- Begin with basic problems
- Understand the logic before optimization
- Test with simple inputs first

### 2. **Practice Regularly**
- Solve problems daily
- Try different approaches
- Time yourself for interview practice

### 3. **Understand Concepts**
- Don't just memorize solutions
- Understand the underlying algorithms
- Learn when to use each approach

### 4. **Test Thoroughly**
- Use edge cases
- Test with large inputs
- Verify your solutions

## ğŸ”§ Customization

### Adding New Problems
1. Create a new file in the appropriate category
2. Follow the existing code structure
3. Include multiple solution approaches
4. Add comprehensive testing
5. Update this README

### Modifying Existing Solutions
- All solutions are modular and well-documented
- Easy to extend with new methods
- Interactive sections can be customized
- Test cases can be modified or extended

## ğŸ“ˆ Performance Considerations

### Time Complexity
- Each solution includes complexity analysis
- Comparison between different approaches
- Benchmarking with large datasets

### Space Complexity
- Memory usage optimization
- In-place vs. additional space trade-offs
- Recursive vs. iterative space usage

## ğŸ¤ Contributing

We welcome contributions! Here's how you can help:

1. **Bug Fixes**: Report and fix any issues
2. **New Solutions**: Add alternative approaches
3. **Documentation**: Improve comments and explanations
4. **Test Cases**: Add more comprehensive testing
5. **New Problems**: Suggest and implement additional problems

## ğŸ“ Support

If you encounter any issues or have questions:
1. Check the code comments for explanations
2. Run the interactive mode for step-by-step guidance
3. Review the test cases for usage examples
4. Refer to this README for overall guidance

## ğŸ¯ Next Steps

After mastering these problems:
1. **Advanced Data Structures**: Trees, graphs, heaps
2. **Dynamic Programming**: Optimization problems
3. **System Design**: Large-scale problem solving
4. **Competitive Programming**: Contest-style problems

## ğŸ“ License

This project is open source and available under the MIT License.

---

**Happy Coding! ğŸš€**

*Master these 50 problems and you'll be well-prepared for technical interviews and competitive programming challenges.*